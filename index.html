<!doctype html>
<html lang="sk">
<head>
<meta charset="utf-8"/>
<title>VSM</title>
<style>
:root {
  --green: rgb(0,137,61);
  --grey: rgb(135,135,135);
  --light: rgb(182,186,194);
  --accent: rgb(161,200,97);

  --hdr-h: 64px;
  --side-w: 400px;
  --side-mult: 2;
}
/* dynamicky doplnen√© z JS pri otvorenom paneli: --side-open-w */

* { box-sizing: border-box; }
body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color: #222; background: #fff; }

header {
  height: var(--hdr-h);
  padding: 10px;
  background: var(--green);
  color: #fff;
  border-bottom: 3px solid var(--accent);
  position: sticky; top: 0; z-index: 10;
}
.controls {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: center;
}

/* Biely n√°pis v zelenej hlaviƒçke */
.controls .brand {
  font-weight: 700;
  font-size: 18px;
  color: #fff;
  letter-spacing: 0.2px;
  margin-right: 12px;
  text-shadow: 0 1px 1px rgba(0,0,0,0.15);
  white-space: nowrap;
}

/* Tlaƒçidl√° */
.btn {
  font-size: 14px;
  padding: 8px 12px;
  border-radius: 8px;
  border: 1px solid #d1d5db;
  background: linear-gradient(180deg, #ffffff 0%, #f3f4f6 100%);
  color: #1f2937;
  cursor: pointer;
  line-height: 1.2;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  user-select: none;
  box-shadow: 0 1px 1px rgba(0,0,0,0.06);
  transition: background 0.2s ease, box-shadow 0.2s ease, transform 0.05s ease, border-color 0.2s ease;
}
.btn:hover { background: #ffffff; border-color: #c7ccd4; box-shadow: 0 2px 6px rgba(0,0,0,0.08); }
.btn:active { transform: translateY(1px); box-shadow: 0 1px 3px rgba(0,0,0,0.1) inset; }
.btn:focus { outline: none; box-shadow: 0 0 0 3px rgba(161,200,97,0.35); border-color: var(--accent); }

/* Ovl√°danie str√°n */
#pageControls input[type="number"] {
  width: 60px; border: 1px solid #d1d5db; border-radius: 8px; background: #ffffff; color: #1f2937; padding: 8px 10px;
}
#pageControls input[type="number"]:focus { outline: none; box-shadow: 0 0 0 3px rgba(161,200,97,0.35); border-color: var(--accent); }

/* Skryt√Ω file input */
#fileInput { display: none; }

.sep { width: 1px; height: 28px; background: rgba(255,255,255,0.5); }

#status { margin-left: auto; font-size: 13px; opacity: 0.9; }

/* Layout */
#main {
  height: calc(100vh - var(--hdr-h));
  width: 100vw;
  position: relative;
  background: #fff;
}

/* Viewer */
#viewer {
  position: absolute; left: 0; top: 0; right: 0; bottom: 0;
  overflow: auto; background: #fff; border-top: 1px solid var(--light);
  transition: right 0.2s ease;
}
body.panel-open #viewer { right: var(--side-open-w, calc(var(--side-w) * var(--side-mult))); }
#canvasWrap { position: relative; margin: 0 auto; }
canvas { display: block; max-width: none; }
.hand { cursor: grab; }
.hand.dragging { cursor: grabbing; }
.crosshair { cursor: crosshair; }

/* Markery */
#markerLayer { position: absolute; left: 0; top: 0; pointer-events: none; }
.marker {
  position: absolute; transform: translate(-50%, -50%);
  background: var(--green); color: #fff; font-weight: 700; font-size: 12px;
  border-radius: 50%; width: 22px; height: 22px; display: flex; align-items: center; justify-content: center;
  box-shadow: 0 1px 4px rgba(0,0,0,0.25); pointer-events: auto; cursor: pointer; user-select: none; border: 2px solid #fff;
}
@keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(161,200,97,0.7); } 100% { box-shadow: 0 0 0 12px rgba(161,200,97,0); } }
.marker.pulse { animation: pulse 1s ease-out 0s 2; }

/* Boƒçn√Ω panel */
#sidePanel {
  position: fixed; right: 0; top: var(--hdr-h); height: calc(100vh - var(--hdr-h));
  width: min(calc(var(--side-w) * var(--side-mult)), 95vw);
  border-left: 2px solid var(--light); background: #fff; display: flex; flex-direction: column;
  transform: translateX(100%); transition: transform 0.2s ease; box-shadow: -6px 0 12px rgba(0,0,0,0.06); z-index: 20;
}
#sidePanel.open { transform: translateX(0); }

#sideHeader {
  padding: 10px; border-bottom: 2px solid var(--light); background: #f7f8fa;
  display: flex; gap: 8px; align-items: center; position: sticky; top: 0; z-index: 5;
}
#tableWrap { flex: 1 1 auto; overflow: auto; background: #fff; }
table { width: 100%; border-collapse: collapse; font-size: 14px; }
thead th {
  position: sticky; top: 0; z-index: 4; background: var(--light); color: #222;
  border-bottom: 2px solid var(--grey); padding: 8px; text-align: left;
}
tbody td { border-bottom: 1px solid #eee; padding: 6px 8px; }
tbody tr:hover td { background: #f9fafb; }
tbody tr.selected td { background: rgba(161,200,97,0.25); }
tbody td[contenteditable="true"] { outline: none; background: #fffdf7; }
td.actions { width: 1%; white-space: nowrap; }

/* Tlaƒçidlo - ƒçerven√Ω kr√≠≈æik */
.iconBtn { padding: 6px 8px; border: none; background: transparent; border-radius: 8px; cursor: pointer; line-height: 1; user-select: none; }
.iconBtn.delete { color: #d11a2a; font-size: 18px; }
.iconBtn.delete:hover { background: #fee; }
.iconBtn.delete:focus { outline: none; box-shadow: 0 0 0 3px rgba(209,26,42,0.25); }

/* Tlaƒçidlo - oko (zobrazi≈• na mape) */
.iconBtn.view { color: var(--green); font-size: 18px; }
.iconBtn.view:hover { background: #eef6e9; }
.iconBtn.view:focus { outline: none; box-shadow: 0 0 0 3px rgba(161,200,97,0.35); }

/* ---- Panelov√° r√∫ƒçka (≈°√≠pka) ---- */
#panelHandle {
  position: fixed; top: calc(var(--hdr-h) + 50%); transform: translateY(-50%); right: 0; z-index: 25;
  width: 28px; height: 64px; display: inline-flex; align-items: center; justify-content: center;
  background: #f7f8fa; color: #333; border: 2px solid var(--light); border-right: none;
  border-top-left-radius: 10px; border-bottom-left-radius: 10px; box-shadow: -4px 0 8px rgba(0,0,0,0.08);
  cursor: pointer; user-select: none;
}
#panelHandle:hover { background: #fff; }
body.panel-open #panelHandle { right: var(--side-open-w, calc(var(--side-w) * var(--side-mult))); }

/* ---- DOH kalkulaƒçka (mod√°l) ---- */
.modalOverlay { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: flex; align-items: center; justify-content: center; z-index: 100; }
.modalOverlay[hidden] { display: none !important; }
.modal { width: min(520px, 92vw); background: #fff; border: 2px solid var(--light); border-radius: 10px; box-shadow: 0 12px 28px rgba(0,0,0,0.18); overflow: hidden; }
.modalHeader { display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; background: #f7f8fa; border-bottom: 2px solid var(--light); }
.modalBody { padding: 12px; display: grid; gap: 12px; }
.field { display: grid; gap: 6px; }
.field.twoCols input { width: 100%; padding: 8px 10px; border: 1px solid #d1d5db; border-radius: 8px; }
.field.twoCols input:focus { outline: none; box-shadow: 0 0 0 3px rgba(161,200,97,0.35); border-color: var(--accent); }
.choices { display: flex; gap: 16px; flex-wrap: wrap; }
.actions { display: flex; gap: 8px; }
.result { padding: 10px; background: #f1f8ec; border: 1px solid rgba(0,137,61,0.25); border-radius: 8px; color: #0b5e2a; font-weight: 700; }
.error { color: #b00020; background: #fdecee; border: 1px solid #f5c2c7; border-radius: 8px; padding: 8px 10px; }
.note { color: #555; font-size: 12px; }
</style>
</head>
<body>
<header>
  <div class="controls">
    <span class="brand">Value Stream Management</span>

    <label for="fileInput" class="btn" title="Vybra≈• PDF s√∫bor">Vybra≈• s√∫bor</label>
    <input id="fileInput" type="file" accept=".pdf,application/pdf"/>

    <button id="exportBtn" class="btn" title="Exportova≈• z√°pisn√≠k a markery do JSON">Export</button>
    <button id="importBtn" class="btn" title="Importova≈• z√°pisn√≠k a markery z JSON">Import</button>
    <input id="importDataInput" type="file" accept=".json,application/json" style="display:none"/>

    <button id="addMarkerToggle" class="btn" title="Prida≈• oƒç√≠slovan√Ω marker do PDF">Prida≈• ƒç√≠slo: OFF</button>
    <button id="toggleHand" class="btn">Pan (ruƒçiƒçka): OFF</button>
    <button id="magnifyToggle" class="btn" title="Lupa: ƒæav√Ωm klikom pribl√≠≈æi≈°, prav√Ωm oddiali≈°">Lupa: OFF</button>
    <button id="centerBtn" class="btn" title="Zobrazi≈• cel√© a vycentrova≈•">Vycentrova≈•</button>

    <button id="dohOpen" class="btn" title="Otvori≈• kalkulaƒçku DOH">DOH</button>

    <span class="sep"></span>

    <div id="pageControls">
      <button id="prevBtn" class="btn">Prev</button>
      <span>Strana:</span>
      <input id="pageNum" type="number" min="1" value="1">
      <span>/ <span id="pageCount">0</span></span>
      <button id="nextBtn" class="btn">Next</button>
    </div>

    <div id="status"></div>
  </div>
</header>

<div id="main">
  <div id="viewer">
    <div id="canvasWrap">
      <canvas id="pdfCanvas"></canvas>
      <div id="markerLayer"></div>
    </div>
  </div>

  <aside id="sidePanel">
    <div id="sideHeader">
      <strong style="color:#222;">Z√°pisn√≠k</strong>
      <button id="addRow" class="btn">Prida≈• riadok</button>
      <button id="clearRows" class="btn" title="Vyƒçisti≈• tabuƒæku">Vyƒçisti≈•</button>
      <button id="downloadCsv" class="btn" title="Stiahnu≈• CSV">CSV</button>
    </div>
    <div id="tableWrap">
      <table id="notesTable">
        <thead>
          <tr>
            <th>ƒå√≠slo</th>
            <th>T√©ma</th>
            <th>Zodpovedn√Ω</th>
            <th>Term√≠n</th>
            <th>√öspora</th>
            <th>Projekt</th>
            <th>Status</th>
            <th>Akcie</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </aside>

  <!-- Boƒçn√° r√∫ƒçka (≈°√≠pka) -->
  <button id="panelHandle" title="Zobrazi≈•/Skry≈• z√°pisn√≠k" aria-label="Zobrazi≈•/Skry≈• z√°pisn√≠k" aria-expanded="false">‚Äπ</button>
</div>

<!-- DOH mod√°l -->
<div id="dohOverlay" class="modalOverlay" hidden>
  <div class="modal">
    <div class="modalHeader">
      <strong>DOH kalkulaƒçka</strong>
      <button id="dohClose" class="btn" title="Zavrie≈•">Zavrie≈•</button>
    </div>

    <div class="modalBody">
      <div class="field">
        <label>Dni v obdob√≠:</label>
        <div class="choices">
          <label><input type="radio" name="dohDays" value="30" checked> DOH30 (30 dn√≠)</label>
          <label><input type="radio" name="dohDays" value="360"> DOH360 (360 dn√≠)</label>
        </div>
      </div>

      <div class="field">
        <label>V√Ωsledok v d≈àoch:</label>
        <div class="choices">
          <label><input type="radio" name="dohResultType" value="work" checked> Pracovn√© dni</label>
          <label><input type="radio" name="dohResultType" value="cal"> Kalend√°rne dni</label>
        </div>
      </div>

      <div class="field twoCols">
        <label for="dohWdaysPerWeek">Pracovn√© dni v t√Ω≈ædni (1‚Äì7)</label>
        <input id="dohWdaysPerWeek" type="number" min="1" max="7" value="5" />
        <small class="note">Be≈æne 5; pri 7‚Äëd≈àovej prev√°dzke nastav 7 (pracovn√© = kalend√°rne).</small>
      </div>

      <div class="field twoCols">
        <label for="dohInventory">Hodnota skladu (napr. WIP / z√°soby) [‚Ç¨]</label>
        <input id="dohInventory" type="number" inputmode="decimal" placeholder="napr. 5871000" />
      </div>

      <div class="field twoCols">
        <label for="dohPerfPeriod">V√Ωkon za obdobie (s√∫ƒçet za 30/360 dn√≠) [‚Ç¨]</label>
        <input id="dohPerfPeriod" type="number" inputmode="decimal" placeholder="napr. s√∫ƒçet COGS/COGM za 30/360 dn√≠" />
      </div>

      <div class="actions">
        <button id="dohCalc" class="btn">Vypoƒç√≠ta≈•</button>
        <button id="dohClear" class="btn" title="Vymaza≈• vstupy">Vymaza≈•</button>
      </div>

      <div id="dohResult" class="result">V√Ωsledok: ‚Äî</div>
      <div id="dohError" class="error" hidden></div>
      <div id="dohNote" class="note"></div>
    </div>
  </div>
</div>

<!-- PDF.js kni≈ænica -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';  

const fileInput = document.getElementById('fileInput');
const exportBtn = document.getElementById('exportBtn');
const importBtn = document.getElementById('importBtn');
const importDataInput = document.getElementById('importDataInput');

const viewer = document.getElementById('viewer');
const canvasWrap = document.getElementById('canvasWrap');
const canvas = document.getElementById('pdfCanvas');
const ctx = canvas.getContext('2d');
const markerLayer = document.getElementById('markerLayer');

const pageNumInput = document.getElementById('pageNum');
const pageCountEl = document.getElementById('pageCount');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');

const toggleHandBtn = document.getElementById('toggleHand');
const magnifyToggleBtn = document.getElementById('magnifyToggle');
const addMarkerToggleBtn = document.getElementById('addMarkerToggle');
const centerBtn = document.getElementById('centerBtn');

const sidePanel = document.getElementById('sidePanel');
const panelHandleBtn = document.getElementById('panelHandle');
const statusEl = document.getElementById('status');

const notesTable = document.getElementById('notesTable');
const tbody = notesTable.querySelector('tbody');
const addRowBtn = document.getElementById('addRow');
const clearRowsBtn = document.getElementById('clearRows');
const downloadCsvBtn = document.getElementById('downloadCsv');

const cols = ['ƒå√≠slo','T√©ma','Zodpovedn√Ω','Term√≠n','√öspora','Projekt','Status'];
let rows = [];

let pdfDoc = null;
let currentPage = 1;
let scale = 1.0;
let fitMode = 'window';
let isHand = false;
let panelOpen = false;
let magnifyOn = false;
let addMarkerOn = false;

const ZOOM_STEP = 1.25;
const FOCUS_SCALE = 2.0;

const PDF_DB_NAME = 'vsmPdfDB';
const PDF_STORE = 'lastPdf';
const PDF_STATE_KEY = 'vsmPdfState';

const WINDOW_NAME_KEY = 'VSM_PDF_CACHE';

const PDF_SESS_DATAURL_KEY = 'vsmPdfDataUrlSess';
const PDF_SESS_NAME_KEY = 'vsmPdfNameSess';

const PDF_DATAURL_KEY = 'vsmPdfDataUrl';
const PDF_NAME_KEY = 'vsmPdfName';

const MARKERS_KEY = 'visioMarkers';

function openPdfDb() {
  return new Promise((resolve, reject) => {
    if (!('indexedDB' in window)) return reject(new Error('IndexedDB nie je podporovan√©'));
    const req = indexedDB.open(PDF_DB_NAME, 1);
    req.onupgradeneeded = () => { const db = req.result; if (!db.objectStoreNames.contains(PDF_STORE)) db.createObjectStore(PDF_STORE); };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error || new Error('Nepodarilo sa otvori≈• DB'));
  });
}

async function blobToDataUrl(blob) {
  return await new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = () => resolve(fr.result);
    fr.onerror = () => reject(fr.error || new Error('FileReader error'));
    fr.readAsDataURL(blob);
  });
}

function dataUrlToArrayBuffer(dataUrl) {
  try {
    const comma = dataUrl.indexOf(',');
    if (comma < 0) return null;
    const meta = dataUrl.slice(0, comma);
    const dataPart = dataUrl.slice(comma + 1);
    const isBase64 = /;base64/i.test(meta);
    let bin;
    if (isBase64) {
      bin = atob(dataPart);
    } else {
      bin = decodeURIComponent(dataPart);
    }
    const len = bin.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) bytes[i] = bin.charCodeAt(i);
    return bytes.buffer;
  } catch (e) {
    console.warn('Dek√≥dovanie Data URL zlyhalo:', e);
    return null;
  }
}

function saveToWindowName(dataUrl, name) {
  try {
    const payload = { k: WINDOW_NAME_KEY, name, dataUrl };
    window.name = JSON.stringify(payload);
  } catch (e) {
    console.warn('Ukladanie do window.name zlyhalo:', e);
  }
}

function readFromWindowName() {
  try {
    if (!window.name) return null;
    const obj = JSON.parse(window.name);
    if (obj && obj.k === WINDOW_NAME_KEY && obj.dataUrl) {
      const ab = dataUrlToArrayBuffer(obj.dataUrl);
      if (ab) return { name: obj.name || 'PDF', arrayBuffer: ab };
    }
  } catch (e) {
    console.warn('ƒå√≠tanie z window.name zlyhalo:', e);
  }
  return null;
}

async function saveLastPdf(arrayBuffer, name) {
  const blob = new Blob([arrayBuffer], { type: 'application/pdf' });

  try {
    const dataUrl = await blobToDataUrl(blob);
    saveToWindowName(dataUrl, name);
  } catch (e) {
    console.warn('Ukladanie do window.name zlyhalo:', e);
  }

  try {
    const dataUrl = await blobToDataUrl(blob);
    sessionStorage.setItem(PDF_SESS_DATAURL_KEY, dataUrl);
    sessionStorage.setItem(PDF_SESS_NAME_KEY, name);
  } catch (e) {
    console.warn('Ukladanie do sessionStorage zlyhalo:', e);
  }

  try {
    const dataUrl = await blobToDataUrl(blob);
    if (dataUrl.length <= 4_800_000) {
      localStorage.setItem(PDF_DATAURL_KEY, dataUrl);
      localStorage.setItem(PDF_NAME_KEY, name);
    } else {
      console.warn('PDF je pr√≠li≈° veƒæk√© pre localStorage fallback.');
    }
  } catch (e) {
    console.warn('Ukladanie do localStorage zlyhalo:', e);
  }

  try {
    const db = await openPdfDb();
    await new Promise((resolve, reject) => {
      const tx = db.transaction(PDF_STORE, 'readwrite');
      tx.oncomplete = () => { db.close(); resolve(); };
      tx.onerror = () => { const err = tx.error || new Error('Tx error'); db.close(); reject(err); };
      tx.objectStore(PDF_STORE).put({ name, data: blob, savedAt: Date.now() }, 'last');
    });
  } catch (e) {
    console.warn('Ukladanie do IndexedDB zlyhalo:', e);
  }
}

async function loadLastPdfRecord() {
  const wn = readFromWindowName();
  if (wn) return wn;

  try {
    const sUrl = sessionStorage.getItem(PDF_SESS_DATAURL_KEY);
    if (sUrl) {
      const ab = dataUrlToArrayBuffer(sUrl);
      if (ab) return { name: sessionStorage.getItem(PDF_SESS_NAME_KEY) || 'PDF', arrayBuffer: ab };
    }
  } catch (e) { console.warn('ƒå√≠tanie zo sessionStorage zlyhalo:', e); }

  try {
    const lUrl = localStorage.getItem(PDF_DATAURL_KEY);
    if (lUrl) {
      const ab = dataUrlToArrayBuffer(lUrl);
      if (ab) return { name: localStorage.getItem(PDF_NAME_KEY) || 'PDF', arrayBuffer: ab };
    }
  } catch (e) { console.warn('ƒå√≠tanie z localStorage zlyhalo:', e); }

  try {
    const db = await openPdfDb();
    const rec = await new Promise((resolve, reject) => {
      const tx = db.transaction(PDF_STORE, 'readonly');
      tx.oncomplete = () => db.close();
      tx.onerror = () => { const err = tx.error || new Error('Tx error'); db.close(); reject(err); };
      const req = tx.objectStore(PDF_STORE).get('last');
      req.onsuccess = () => resolve(req.result || null);
      req.onerror = () => reject(req.error || new Error('Get error'));
    });
    if (rec && rec.data) {
      const ab = await rec.data.arrayBuffer();
      return { name: rec.name || 'PDF', arrayBuffer: ab };
    }
  } catch (e) { console.warn('ƒå√≠tanie z IndexedDB zlyhalo:', e); }

  return null;
}

function savePdfState() {
  if (!pdfDoc) return;
  try { localStorage.setItem(PDF_STATE_KEY, JSON.stringify({ page: currentPage, scale, fitMode })); } catch {}
}
function loadPdfState() {
  try { return JSON.parse(localStorage.getItem(PDF_STATE_KEY) || '{}'); } catch { return {}; }
}

function loadRows() {
  try { const raw = localStorage.getItem('visioNotesRows'); rows = raw ? JSON.parse(raw) : []; }
  catch { rows = []; }
  sortRowsInPlace();
}
function saveRows() { localStorage.setItem('visioNotesRows', JSON.stringify(rows)); }
function sortRowsInPlace() {
  rows.sort((a, b) => {
    const na = parseInt(a['ƒå√≠slo'], 10);
    const nb = parseInt(b['ƒå√≠slo'], 10);
    const aNum = Number.isInteger(na), bNum = Number.isInteger(nb);
    if (aNum && bNum) return na - nb;
    if (aNum && !bNum) return -1;
    if (!aNum && bNum) return 1;
    return 0;
  });
}
function renderRows() {
  sortRowsInPlace(); saveRows();
  tbody.innerHTML = '';
  rows.forEach((r, i) => {
    const tr = document.createElement('tr'); tr.dataset.index = String(i);
    cols.forEach((cKey) => {
      const td = document.createElement('td');
      td.contentEditable = 'true';
      td.textContent = r[cKey] ?? '';
      td.addEventListener('input', () => { rows[i][cKey] = td.textContent; saveRows(); });
      if (cKey === 'ƒå√≠slo') td.addEventListener('blur', () => { sortRowsInPlace(); renderRows(); });
      tr.appendChild(td);
    });

    const tdAct = document.createElement('td'); tdAct.className = 'actions'; tdAct.contentEditable = 'false';

    const viewBtn = document.createElement('button');
    viewBtn.className = 'iconBtn view';
    viewBtn.title = 'Zobrazi≈• ƒç√≠slo na mape';
    viewBtn.setAttribute('aria-label', 'Zobrazi≈• ƒç√≠slo na mape');
    viewBtn.textContent = 'üëÅ';
    viewBtn.addEventListener('click', () => {
      const num = parseInt(rows[i]['ƒå√≠slo'], 10);
      if (isNaN(num)) {
        statusEl.textContent = 'Riadok nem√° platn√© ƒç√≠slo.';
        return;
      }
      focusMarkerByNumber(num);
    });
    tdAct.appendChild(viewBtn);

    const delBtn = document.createElement('button'); 
    delBtn.className = 'iconBtn delete';
    delBtn.title = 'Odstr√°ni≈• riadok'; 
    delBtn.setAttribute('aria-label','Odstr√°ni≈• riadok'); 
    delBtn.textContent = '‚úñ';
    delBtn.addEventListener('click', () => {
      const num = parseInt(rows[i]['ƒå√≠slo'], 10);
      rows.splice(i, 1); sortRowsInPlace(); saveRows(); renderRows();
      if (!isNaN(num)) removeMarkerByNumber(num);
    });
    tdAct.appendChild(delBtn);

    tr.appendChild(tdAct);
    tbody.appendChild(tr);
  });
}
function addEmptyRow() { const r = {}; cols.forEach(k => r[k]=''); rows.push(r); sortRowsInPlace(); saveRows(); renderRows(); tbody.lastElementChild?.firstElementChild?.focus(); }
function addRowWithNumber(num) { const r = {}; cols.forEach(k => r[k]=''); r['ƒå√≠slo']=String(num); rows.push(r); sortRowsInPlace(); saveRows(); renderRows(); selectRowByNumber(num); }

tbody.addEventListener('click', (e) => {
  const tr = e.target.closest('tr'); if (!tr || e.target.closest('button')) return;
  tbody.querySelectorAll('tr').forEach(r => r.classList.remove('selected')); tr.classList.add('selected');
});

function selectRowByNumber(num) {
  const i = rows.findIndex(r => parseInt(r['ƒå√≠slo'],10) === num);
  if (i >= 0) {
    const tr = tbody.children[i];
    tbody.querySelectorAll('tr').forEach(r => r.classList.remove('selected'));
    tr?.classList.add('selected');
    tr?.scrollIntoView({ block: 'nearest' });
  }
}
addRowBtn.addEventListener('click', addEmptyRow);
clearRowsBtn.addEventListener('click', () => {
  if (!confirm('Naozaj vyƒçisti≈• v≈°etky riadky (a markery)?')) return;
  rows = [];
  saveRows();
  renderRows();
  markers = [];
  saveMarkers();
  renderMarkers();
});
downloadCsvBtn.addEventListener('click', () => {
  sortRowsInPlace();
  const csvHeader = [...cols, 'Akcie'].join(';');
  const csvRows = rows.map(r =>
    cols.map(k => (r[k] ?? '').replace(/;/g, ',')).join(';')
  );
  const csvStr = [csvHeader, ...csvRows].join('\n');
  const blob = new Blob([csvStr], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'zapisnik.csv';
  a.click();
  URL.revokeObjectURL(url);
});

// Marker handling
let markers = [];
function loadMarkers() {
  try {
    const raw = localStorage.getItem(MARKERS_KEY);
    markers = raw ? JSON.parse(raw) : [];
  } catch {
    markers = [];
  }
}
function saveMarkers() {
  localStorage.setItem(MARKERS_KEY, JSON.stringify(markers));
}
function renderMarkers() {
  markerLayer.innerHTML = '';
  markerLayer.style.width = canvas.width + 'px';
  markerLayer.style.height = canvas.height + 'px';
  markers.filter(m => m.page === currentPage).forEach(m => {
    const el = document.createElement('div');
    el.className = 'marker';
    el.dataset.number = String(m.number);
    el.textContent = m.number;
    el.style.left = (m.xNorm * canvas.width) + 'px';
    el.style.top = (m.yNorm * canvas.height) + 'px';
    el.addEventListener('click', () => {
      selectRowByNumber(m.number);
      setPanelOpen(true);
      el.classList.add('pulse');
      setTimeout(() => el.classList.remove('pulse'), 1200);
    });
    markerLayer.appendChild(el);
  });
}
function getNextNumber() {
  const used = new Set();
  markers.forEach(m => {
    const n = parseInt(m.number, 10);
    if (Number.isInteger(n) && n > 0) used.add(n);
  });
  rows.forEach(r => {
    const n = parseInt(r['ƒå√≠slo'], 10);
    if (Number.isInteger(n) && n > 0) used.add(n);
  });
  let i = 1;
  while (used.has(i)) i++;
  return i;
}
function removeMarkerByNumber(num) {
  const before = markers.length;
  markers = markers.filter(m => m.number !== num);
  if (markers.length !== before) {
    saveMarkers();
    renderMarkers();
  }
}
function placeMarkerAtEvent(e) {
  if (e.button !== 0) return;
  const rect = canvas.getBoundingClientRect();
  const xPx = e.clientX - rect.left;
  const yPx = e.clientY - rect.top;
  const xNorm = xPx / canvas.width;
  const yNorm = yPx / canvas.height;
  const num = getNextNumber();
  markers.push({ number: num, page: currentPage, xNorm, yNorm });
  saveMarkers();
  renderMarkers();
  addRowWithNumber(num);
  const mEl = markerLayer.querySelector(`.marker[data-number="${num}"]`);
  mEl?.classList.add('pulse');
  setTimeout(() => mEl?.classList.remove('pulse'), 1200);
  statusEl.textContent = 'Pridan√© ƒç√≠slo ' + num + ' na stranu ' + currentPage;
}
async function focusMarkerByNumber(num) {
  const m = markers.find(x => x.number === num);
  if (!m) {
    statusEl.textContent = 'K riadku nie je priraden√Ω marker (ƒç√≠slo: ' + num + ').';
    return;
  }
  if (currentPage !== m.page) {
    currentPage = m.page;
    fitMode = null;
    await renderPage();
  }
  fitMode = null;
  if (scale < FOCUS_SCALE) scale = FOCUS_SCALE;
  await renderPage();
  const x = m.xNorm * canvas.width,
    y = m.yNorm * canvas.height;
  viewer.scrollLeft = Math.max(
    0,
    Math.min(
      x - viewer.clientWidth / 2,
      Math.max(0, viewer.scrollWidth - viewer.clientWidth)
    )
  );
  viewer.scrollTop = Math.max(
    0,
    Math.min(
      y - viewer.clientHeight / 2,
      Math.max(0, viewer.scrollHeight - viewer.clientHeight)
    )
  );
  const mEl = markerLayer.querySelector(`.marker[data-number="${num}"]`);
  mEl?.classList.add('pulse');
  setTimeout(() => mEl?.classList.remove('pulse'), 1200);
}

// Viewer
fileInput.addEventListener('change', async e => {
  const file = e.target.files?.[0];
  if (!file) return;
  try {
    const ab = await file.arrayBuffer();
    await loadPdf(ab, file.name);
    await saveLastPdf(ab, file.name);
    statusEl.textContent = 'PDF naƒç√≠tan√© a ulo≈æen√© pre obnovu: ' + file.name;
  } catch (err) {
    console.warn('Naƒç√≠tanie/Ulo≈æenie PDF zlyhalo:', err);
    statusEl.textContent = 'PDF sa nepodarilo naƒç√≠ta≈•/ulo≈æi≈•.';
  } finally {
    fileInput.value = '';
  }
});

async function loadPdf(arrayBuffer, name = 'PDF') {
  clearViewer();
  statusEl.textContent = 'Naƒç√≠tavam...';
  try {
    pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  } catch (err) {
    statusEl.textContent = 'PDF sa nepodarilo naƒç√≠ta≈•: ' + err.message;
    console.warn(err);
    return;
  }
  pageCountEl.textContent = pdfDoc.numPages;
  currentPage = 1;
  pageNumInput.value = currentPage;
  statusEl.textContent = 'Naƒç√≠tan√©: ' + name + ' ‚Ä¢ ' + pdfDoc.numPages + ' str√°n';
  fitMode = 'window';
  await renderPage();
  viewer.scrollLeft = 0;
  viewer.scrollTop = 0;
  savePdfState();
}
function clearViewer() {
  pdfDoc = null;
  currentPage = 1;
  scale = 1.0;
  fitMode = 'window';
  canvas.width = 0;
  canvas.height = 0;
  pageCountEl.textContent = '0';
  pageNumInput.value = 1;
  markerLayer.innerHTML = '';
}
function clampScale(s) {
  return Math.max(0.2, Math.min(s, 6.0));
}
async function renderPage() {
  if (!pdfDoc) return;
  const page = await pdfDoc.getPage(currentPage);
  if (fitMode === 'window') {
    const baseVp = page.getViewport({ scale: 1.0 });
    const scaleW = viewer.clientWidth / baseVp.width;
    const scaleH = viewer.clientHeight / baseVp.height;
    scale = clampScale(Math.min(scaleW, scaleH));
  }
  const viewport = page.getViewport({ scale });
  canvas.width = viewport.width;
  canvas.height = viewport.height;
  canvasWrap.style.width = viewport.width + 'px';
  await page.render({ canvasContext: ctx, viewport }).promise;
  pageNumInput.value = currentPage;
  renderMarkers();
  savePdfState();
}
prevBtn.addEventListener('click', async () => {
  if (!pdfDoc) return;
  if (currentPage > 1) {
    currentPage--;
    await renderPage();
    if (fitMode === 'window') {
      viewer.scrollLeft = 0;
      viewer.scrollTop = 0;
    }
  }
});
nextBtn.addEventListener('click', async () => {
  if (!pdfDoc) return;
  if (currentPage < pdfDoc.numPages) {
    currentPage++;
    await renderPage();
    if (fitMode === 'window') {
      viewer.scrollLeft = 0;
      viewer.scrollTop = 0;
    }
  }
});
pageNumInput.addEventListener('change', async () => {
  if (!pdfDoc) return;
  let p = parseInt(pageNumInput.value, 10);
  if (isNaN(p)) return;
  currentPage = Math.max(1, Math.min(p, pdfDoc.numPages));
  await renderPage();
  if (fitMode === 'window') {
    viewer.scrollLeft = 0;
    viewer.scrollTop = 0;
  }
});

// Pan a ostatn√© ovl√°dania ...

// **HLAVN√Å ZMENA: pri naƒç√≠tan√≠ obnovujeme ulo≈æen√© PDF a z√°pisn√≠k**
window.addEventListener('load', async () => {
  // Obnov PDF zo storage (window.name, sessionStorage, localStorage, IndexedDB)
  const rec = await loadLastPdfRecord();
  if (rec && rec.arrayBuffer) {
    await loadPdf(rec.arrayBuffer, rec.name || 'PDF');
    const st = loadPdfState();
    if (st && pdfDoc) {
      if (Number.isInteger(st.page)) currentPage = Math.max(1, Math.min(st.page, pdfDoc.numPages));
      if (typeof st.scale === 'number') {
        scale = clampScale(st.scale);
        fitMode = st.fitMode || null;
      }
      await renderPage();
    }
    statusEl.textContent = 'Obnoven√© posledn√© PDF: ' + (rec.name || 'PDF') + ' ‚Ä¢ ' + pdfDoc.numPages + ' str√°n';
  } else {
    statusEl.textContent = 'Vyberte PDF s√∫bor (tlaƒçidlo hore vƒæavo).';
  }

  // Obnov z√°pisn√≠k zo storage
  loadRows();
  renderRows();
});
